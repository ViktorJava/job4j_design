[Перейти на домашнюю страницу](../README.md)

# Блок 1 - Структуры данных и алгоритмы.
> Изученные темы в процессе прохождения блокa.

## 0. Инструменты. 
Подготовка окружения для уровня **"Джуниор"**:
* Установка, настройка или обновление **JDK**.
* Установка, настройка, или обновление (не рекомендовано) **IDEA**.
* **GitHub**. Создание проекта с нуля.
* **Maven**. Настройка и добавление **dependencies**.
* **Checkstyle**.
* **JaCoCo**.
* Интеграция с **Travis CI**.
* **Codecov** - Continuous integration 

## 1. Iterator

   * [Что такое итератор.](https://github.com/ViktorJava/job4j_design/issues/6) Итератор для одномерного массива чисел, отдаёт элементы в обратном порядке. 
   * [Итератор для двухмерного массива.](https://github.com/ViktorJava/job4j_design/issues/8) Написать для двумерного массива, итератор, который последовательно вернет элементы.
   * [Создать итератор четные числа.](github.com/ViktorJava/job4j_design/issues/9) Создать итератор возвращающий только четные цифры. Итератор должен принимать список произвольных чисел.
   * [FlatMap для Iterator](https://https://github.com/ViktorJava/job4j_design/issues/10) В `Stream API` есть метод `flatMap`. Он позволяет получить из элемента потока другой поток. Нужно создать подобное поведение.
   
## 2. Generic 

   * [Что такое обобщенные типы (generics)](https://github.com/ViktorJava/job4j_design/issues/13) Добавить 3 модели данных, которые образуют иерархию наследования:
`Animal -> Predator -> Tiger`. Далее применяя обощение, создавались различные ограничения.
   * [Реализовать SimpleArray.](https://github.com/ViktorJava/job4j_design/issues/15) В этом задании необходимо сделать универсальную обертку над массивом. Некоторые требования к реализации по ссылке.
   * [Реализовать Store.](https://github.com/ViktorJava/job4j_design/issues/16) В этом задании необходимо реализовать контейнеры для хранения объектов.

## 3. List. Структура данных – список, описывается интерфейсом List

   * [Динамический список на массиве.](https://github.com/ViktorJava/job4j_design/issues/18) Реализовать динамический массив `ArrayList`. Итератор должен реализовывать **fail-fast** поведение.
   * [Создать контейнер на базе связанного списка.](https://github.com/ViktorJava/job4j_design/issues/19) Необходимо создать динамический контейнер с методами: `add(E value)`; `E get(int index)`; реализовать интерфейс `Iterable<E>`. Внутри контейнер должен базироваться на связанном списке `Node<E>` node. Использовать стандартные коллекции **JDK (ArrayList, LinkedList и т.д.)** запрещено. Контейнер должен быть динамическим, т.е. увеличиваться по мере добавления элементов. Итератор должен реализовывать **fail-fast** поведение.
   * [Удалить head в односвязном списке.](https://github.com/ViktorJava/job4j_design/issues/20) Необходимо реализовать метод `delete` для односвязного списка. **Implementation Note:** Реализовать метод `deleteFirst()`. В методе `delete` должна быть проверка, что `head != null`. Этот случай проверяется в тесте.
   * [Используя контейнер на базе связанного списка создать контейнер Stack.](https://github.com/ViktorJava/job4j_design/issues/21) Написать класс `SimpleStack`. **Stack** лучше всего реализовать на базе связанного списка. Почему связанных список лучше всего подходит для этого? Связанный список умеет быстро вставлять данные и удалять. Это как раз те действия, которые нужны для **Stack**.
   * [Очередь на двух стеках.](https://github.com/ViktorJava/job4j_design/issues/22) Реализовать класс `SimpleQueue` это очередь **FIFO**. Метод `poll()` - должен возвращать первое значение и удалять его из коллекции. Метод `push(T value)` - помещает значение в конец .
   * [Перевернуть связанный список.](https://github.com/ViktorJava/job4j_design/issues/24) Задан односвязный список. В нем есть метод `revert`. Этот метод должен переставить элементы в обратном порядке. Например, Было 1, 2, 3 поле метода `revert` будет 3, 2, 1.
   * [ListIterator.](https://github.com/ViktorJava/job4j_design/issues/25) В качестве альтернативы "обычному" итератору, есть `ListIterator`. Он обладает **fail-safe** поведением, это значит, что мы можем менять коллекцию по ходу итерирования, но только с помощью самого итератора. 

## 4. Set. Всё что касается интерфейса Set<E> и его наиболее употребительными реализациями.
* [Реализовать коллекцию Set на массиве](https://github.com/ViktorJava/job4j_design/issues/26) Реализовать коллекцию `SimpleSet`. Коллекция должна обеспечивать `boolean add(E e)` и реализовывать `Iterable<E>`. Коллекция не должна хранить дубликаты.

## 5. Map. Пришло время изучить одну из самых часто используемых структур данных – HashMap
* [Hash структуры.]() Одна из самых часто используемых структур данных – `HashMap`
* [Модель User.]() Создаётся модель, с которой необходимо работать в дальнейшем проекте.
* [Без переопределения equals и hashCode.]()
* [Переопределить только hashCode.]()
* [Переопределить только equals.]()
* [Переопределить и equals и hashCode.]()
* [Коллизии Map.]()
* [Как вычисляются hash функция.]()
* [Реализовать собственную структуру данных - HashMap.]()
* [Как переопределяют метод hashCode.]()

## 6. Tree. Изучение структуры - деревья.
* [Создать элементарную структуру дерева.]() Познакомимся с алгоритмом обхода дерева в ширину - **breadth first search**.
* [Добавить метод boolean isBinary().]() Метод должен проверять количество дочерних элементов в дереве. Если их > 2 - то дерево не бинарное.

## Лицензия

[MIT. Free Software!](https://github.com/ViktorJava/job4j/tree/master/LICENSE)

---

[Перейти на домашнюю страницу](../README.md)
