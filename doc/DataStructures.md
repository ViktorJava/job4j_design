[Перейти на домашнюю страницу](../README.md)

# Блок 1 - Структуры данных и алгоритмы.
> Изученные темы в процессе прохождения блока.

## 0. Инструменты. 
Подготовка окружения для уровня **"Джуниор"**:
* Установка, настройка или обновление **JDK**.
* Установка, настройка, или обновление (не рекомендовано) **IDEA**.
* **GitHub**. Создание проекта с нуля.
* **Maven**. Настройка и добавление **dependencies**.
* **Checkstyle**.
* **JaCoCo**.
* Интеграция с **Travis CI**.
* **Codecov** - Continuous integration 

## 1. Iterator

   * [Что такое итератор.](https://github.com/ViktorJava/job4j_design/issues/6) Итератор для одномерного массива чисел, отдаёт элементы в обратном порядке. 
   * [Итератор для двухмерного массива.](https://github.com/ViktorJava/job4j_design/issues/8) Написать для двумерного массива, итератор, который последовательно вернет элементы.
   * [Создать итератор четные числа.](https://github.com/ViktorJava/job4j_design/issues/9) Создать итератор возвращающий только четные цифры. Итератор должен принимать список произвольных чисел.
   * [FlatMap для Iterator](https://github.com/ViktorJava/job4j_design/issues/10) В `Stream API` есть метод `flatMap`. Он позволяет получить из элемента потока другой поток. Нужно создать подобное поведение.
   
## 2. Generic 

   * [Что такое обобщенные типы (generics)](https://github.com/ViktorJava/job4j_design/issues/13) Добавить 3 модели данных, которые образуют иерархию наследования:
`Animal -> Predator -> Tiger`. Далее применяя обобщение, создавались различные ограничения.
   * [Реализовать SimpleArray.](https://github.com/ViktorJava/job4j_design/issues/15) В этом задании необходимо сделать универсальную обертку над массивом. Некоторые требования к реализации по ссылке.
   * [Реализовать Store.](https://github.com/ViktorJava/job4j_design/issues/16) В этом задании необходимо реализовать контейнеры для хранения объектов.

## 3. List. Структура данных – список, описывается интерфейсом List

   * [Динамический список на массиве.](https://github.com/ViktorJava/job4j_design/issues/18) Реализовать динамический массив `ArrayList`. Итератор должен реализовывать **fail-fast** поведение.
   * [Создать контейнер на базе связанного списка.](https://github.com/ViktorJava/job4j_design/issues/19) Необходимо создать динамический контейнер с методами: `add(E value)`; `E get(int index)`; реализовать интерфейс `Iterable<E>`. Внутри контейнер должен базироваться на связанном списке `Node<E>` node. Использовать стандартные коллекции **JDK (ArrayList, LinkedList и т.д.)** запрещено. Контейнер должен быть динамическим, т.е. увеличиваться по мере добавления элементов. Итератор должен реализовывать **fail-fast** поведение.
   * [Удалить head в односвязном списке.](https://github.com/ViktorJava/job4j_design/issues/20) Необходимо реализовать метод `delete` для односвязного списка. **Implementation Note:** Реализовать метод `deleteFirst()`. В методе `delete` должна быть проверка, что `head != null`. Этот случай проверяется в тесте.
   * [Используя контейнер на базе связанного списка создать контейнер Stack.](https://github.com/ViktorJava/job4j_design/issues/21) Написать класс `SimpleStack`. **Stack** лучше всего реализовать на базе связанного списка. Почему связанных список лучше всего подходит для этого? Связанный список умеет быстро вставлять данные и удалять. Это как раз те действия, которые нужны для **Stack**.
   * [Очередь на двух стеках.](https://github.com/ViktorJava/job4j_design/issues/22) Реализовать класс `SimpleQueue` это очередь **FIFO**. Метод `poll()` - должен возвращать первое значение и удалять его из коллекции. Метод `push(T value)` - помещает значение в конец.
   * [Перевернуть связанный список.](https://github.com/ViktorJava/job4j_design/issues/24) Задан односвязный список. В нем есть метод `revert`. Этот метод должен переставить элементы в обратном порядке. Например, Было 1, 2, 3 поле метода `revert` будет 3, 2, 1.
   * [ListIterator.](https://github.com/ViktorJava/job4j_design/issues/25) В качестве альтернативы "обычному" итератору, есть `ListIterator`. Он обладает **fail-safe** поведением, это значит, что мы можем менять коллекцию по ходу итерирования, но только с помощью самого итератора. 

## 4. Set. Всё что касается интерфейса Set<E> и его наиболее употребительными реализациями.
* [Реализовать коллекцию Set на массиве](https://github.com/ViktorJava/job4j_design/issues/26) Реализовать коллекцию `SimpleSet`. Коллекция должна обеспечивать `boolean add(E e)` и реализовывать `Iterable<E>`. Коллекция не должна хранить дубликаты.

## 5. Map. Пришло время изучить одну из самых часто используемых структур данных – HashMap
* Изучение **Hash** структуры. Одна из самых часто используемых структур данных – `HashMap`
* [Модель User.](https://github.com/ViktorJava/job4j_design/issues/27) Создаётся модель, с которой необходимо работать в дальнейшем проекте.
* [Без переопределения equals и hashCode.](https://github.com/ViktorJava/job4j_design/issues/27)
* [Переопределить только hashCode.](https://github.com/ViktorJava/job4j_design/issues/27)
* [Переопределить только equals.](https://github.com/ViktorJava/job4j_design/issues/27)
* [Переопределить и equals и hashCode.](https://github.com/ViktorJava/job4j_design/issues/27)
* [Коллизии в **Hashtable** структурах и как они разрешаются в **Java**.](https://github.com/ViktorJava/job4j_design/issues/30)
* Как вычисляются `hash` функция в **HashMap**. Для чего используются или могут быть использованы операторы %, &, >>>
* [Реализовать собственную структуру данных - HashMap.](https://github.com/ViktorJava/job4j_design/issues/28)
* [Как переопределяют метод hashCode.](https://github.com/ViktorJava/job4j_design/commit/23ca3bfa6b6e5fb854dcfd0cfb11e6e5ccea8cf4)

## 6. Tree. Изучение структуры деревья.
* [Создать элементарную структуру дерева.](https://github.com/ViktorJava/job4j_design/issues/29) Познакомимся с алгоритмом обхода дерева в ширину - **breadth first search**.
* [Добавить метод boolean isBinary().](https://github.com/ViktorJava/job4j_design/issues/29) Метод должен проверять количество дочерних элементов в дереве. Если элементов > 2, необходимо считать, что дерево не является бинарным.

## 7. Экзамен. Структуры данных и алгоритмы.
**Контрольные вопросы. Collections. Pro.**
1. Что такое **generic.**
2. Что такое **wild cards.**
3. Что такое **bound wild cards.**
4. Что такое **unbounded wild cards.**
5. Где хранится информация про **Generics**.
6. Как можно получить тип **Generics**.
7. Что такое итератор.
8. Что такое коллекции.
9. Назовите базовые интерфейсы коллекций.
10. Расскажите реализации интерфейса `List`.
11. Расскажите реализации интерфейса `Set`.
12. Расскажите реализации интерфейса `Map`.
13. Отличие `ArrayList` от `LinkedList`.
14. Отличие `Set` от `List`.
15. Расскажите про методы `Object` `hashCode` и `equals`.
16. Расскажите про реализации `Map`.
17. Расскажите, что такое коллизии в `Map`. Как с ними бороться.
18. Расскажите, что такое анализ алгоритма.
19. Какая временная сложность алгоритмов(O-нотация) добавления, замены и удаления в каждой из коллекций. С чем связаны отличия.
20. Расскажите реализации данных очередей и стеков.
21. Расскажите про реализации деревьев.
22. Что такое **loadFactor.**

### 7.1. Проект: "Почта"
По результатам проверки знаний, ментором, было предложено выполнить [техническое задание](https://github.com/ViktorJava/mail)
### 7.2. Расчёт статистики по коллекции.
[Для закрепления полученных знаний, необходимо выполнить задание.](https://github.com/ViktorJava/job4j_design/issues/32) 

## Лицензия

[MIT. Free Software!](https://github.com/ViktorJava/job4j/tree/master/LICENSE)

---

[Перейти на домашнюю страницу](../README.md)
