Для работы проекта tracker я выбрал SerialGC. Руководствовался я теми соображениями,
что он менее эффективный к экстримальным нагрузкам в условиях технических ограничений.

Настройки VM оставил по умолчанию, задал SerialGC и указал запись лога GC в файл.

В результате получил такое распределение памяти.

Eden space:
максимально доступно 543.56Мб
зарезервировано 38.3Мб
использовано 37Мб

S0:
максимально доступно 67.8Мб
зарезервировано 4.2Мб
S1:
максимально доступно 67.8Мб
зарезервировано 4.2Мб

OldGen:
максимально доступно 1.32Гб
зарезервировано 85.3Мб (3%)
использовано 2.74Мб

MetaSpace:
максимально доступно 1Гб
зарезервировано 7.7Мб
использовано 7.10Мб

итого:
зарезервировано 130Мб
использовано: 43Мб

за 13 минут работы:
выполнено 4 минорных уборки мусора по 5мс каждая
Создано 136МБ данных со скоростью 121кб/сек

Применял
jps
jhsdb jmap --heap --pid <pid>
jstat -gcutil <pid> 30000 300


Далее сконфигурировал VM экстримальным образом:
-XX:+UseSerialGC
-Xmx3m
-XX:SurvivorRatio=1
-XX:NewRatio=1
-XX:MaxMetaspaceSize=9m
-Xlog:gc*:file=\Desktop\tracker\log.log:time

jhsdb jmap --heap --pid 11492
В результате получил следующее распределение памяти:
Old space: 2Mb
S0 и S1: 640Kb
Eden space: 768Kb
Metaspace: 9Mb

В течении 7 минут работала программа, а я в это время создавал заявки.
Наблюдал как после заполнения Edem, участок S0 не использовался и только работал S1.
В это время участок OldGen так-же был заполнен.
Удалось создать 45 заявок и получил OutOfMemoryError
Память которую занимали созданные мною заявки, FullGC удалить не смог по известным причинам.

В результате эксперемента, я делаю выводы:
1. утечек памяти в приложении нет.
2. Если приложение не имеет утечек памяти, его очень сложно сломать.
3. VM и GC это отличная и надёжная штука!
